/*
 * Atmel maXTouch Touchscreen driver Plug in
 *
 * Copyright (C) 2013 Atmel Co.Ltd
 *
 * Author: Pitter Liao <pitter.liao@atmel.com>
 *
 * This program is free software; you can redistribute  it and/or modify it
 * under  the terms of  the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the  License, or (at your
 * option) any later version.
 *
 */

/****************************************************************
	Pitter Liao add for macro for the global platform
	email:  pitter.liao@atmel.com
	mobile: 13244776877
-----------------------------------------------------------------*/
#define PLUG_VERSION 0x0056
/*----------------------------------------------------------------
0.56:
1 diganostic interface changed
0.55
1 support wdc plugin
0.54
1 misc init add pl_flag parameters
0.53
1 clip interface
0.52
1 diagnose command wait at least for 1 interval for status stable
0.50
1 support gesture list
2 modify mxt_diagnostic_command parameter
0.47
1 add reset watchdog
2 add t6 message watchdog
0.46
1 alloc mem for store plugin parameter instead of gloable parameter
0.45
1 disable plugin in default

0.44
1 fix busg and store/show function
2 support internal threshold and algorithm in T100 workaround
3 support resume flag to sub plugin
4 fixed bug in dualx threshold

0.43
1 add t65 lpfilter control
0.42
1 deltet print information
2 impromve
0.41:
1 add invlaid value check
0.40
1 t65 support
0.39
1 fixed bugs which will crash when pluging not inited
0.38
1 t80 support
2 compatible bootloader mode
0.36
1 check inited tag at init()
0.35
1 add mxt_plugin_hook_reg_init
0.34
1 fixed bugs in deinit
0.33
1 fixed issue when plugin running but call plug_deinit
0.32
1 change check and calibration running indendent plug state
2 fix some bugs at _store()
0.31
1 modify print_trunk()
0.3
1 add t9/t100,t55 interface
0.2
1 add t61 support
2 modify t8 array to support step palm weaker
3 process state even when workaround is pause
0.11
1 version for simple workaround without debug message
0.1
1 first version support t37 and t72
*/

#include "plug.h"

static int mxt_get_obj_cfg(void *pl_dev, struct reg_config *config, unsigned long flag);
static int mxt_set_obj_cfg(void *pl_dev, struct reg_config *config, u8 *stack_buf, unsigned long flag);

static void plug_set_and_clr_flag(void * pl_dev, int mask_s, int mask_c)
{
	struct plug_interface *pl = pl_dev;
	struct plug_observer *obs = &pl->observer;

	set_and_clr_flag(mask_s, mask_c, &obs->flag);
}

size_t dec_dump_to_buffer(const char *prefix, const void *buf, size_t num, int groupsize,
			char *linebuf, size_t linebuflen)
{
	int j, lx = 0;

	if (prefix)
		lx += scnprintf(linebuf, linebuflen - lx, "%s: ", prefix);

	if (groupsize == sizeof(s16))
		for (j = 0; j < num; j++)
			lx += scnprintf(linebuf + lx, linebuflen - lx,
					"%s%7d", j ? " " : "", *((s16 *)buf + j));
	else if(groupsize == sizeof(s32))
		for (j = 0; j < num; j++)
			lx += scnprintf(linebuf + lx, linebuflen - lx,
					"%s%12d", j ? " " : "", *((s32 *)buf + j));
	else
		for (j = 0; j < num; j++)
			lx += scnprintf(linebuf + lx, linebuflen - lx,
					"%s%5d", j ? " " : "", *((s8 *)buf + j));

	if (lx == linebuflen) 
		lx--;

	linebuf[lx++] = '\n';
	linebuf[lx++] = '\0';

	return lx;
}

void print_dec_matrix(const char *level,const char *prefix_str,const void *buf,int x_size,int y_size)
{
	const s16 *ptr = buf;
	int i;
	unsigned char linebuf[7 * y_size + 1];

	for (i = 0; i < x_size; i ++) {
		dec_dump_to_buffer(NULL, ptr + i * y_size, y_size, 2,
				   linebuf, sizeof(linebuf));
		printk("%s[mxt]%s\t%3d:  %s\n", level, prefix_str, i, linebuf);
	}
}

void print_dec16_buf(const char *level,const char *prefix_str,const s16 *buf,int num)
{
	const s16 *ptr = buf;
	unsigned char linebuf[8 * num + 1];

	dec_dump_to_buffer(NULL, ptr, num, 2,
			   linebuf, sizeof(linebuf));
	printk("%s[mxt]%10s:  %s", level, prefix_str, linebuf);
}

void print_matrix(const char *prefix,const s16 *buf,int x_size,int y_size)
{
	if (prefix)
		printk(KERN_INFO "[mxt]Print surface %s :\n",prefix);
	else
		printk(KERN_INFO "[mxt]Print address %p :\n",buf);

	print_dec_matrix(KERN_INFO,"    ",buf,x_size,y_size);
}

void print_trunk(const u8 *data, int pos, int len)
{
//#define CONFIG_MXT_TRACK_TRUNK_DATA 1024
#if defined(CONFIG_MXT_TRACK_TRUNK_DATA)
	u8 *buf = kmalloc(CONFIG_MXT_TRACK_TRUNK_DATA, GFP_KERNEL);
	if (buf == NULL)
		return;

	if (!len) {
		printk(KERN_INFO "[mxt] error len pos %d offset %d\n", pos, len);
		return;
	}

	if (len + 1 > CONFIG_MXT_TRACK_TRUNK_DATA) {
		printk(KERN_INFO "[mxt] too long string: pos %d offset %d\n", pos, len);
		len = sizeof(buf) - 1;
	}
	memcpy(buf, data + pos, len);
	buf[len] = '\0';
	printk(KERN_INFO "[mxt] %s \n",buf);
	kfree(buf);
#endif
}

static int config_matrix_init(struct mxt_config *dcfg, u8 matrix_xsize, u8 matrix_ysize)
{
	int i;

	//matrix retagle
	dcfg->m[MX].x0 = 0;
	dcfg->m[MX].y0 = 0;
	dcfg->m[MX].x1 = matrix_xsize - 1;
	dcfg->m[MX].y1 = matrix_ysize - 1;

	if (!dcfg->t15.xsize) {
		//aa absolute position
		dcfg->m[MX_POS].x0 = dcfg->t9_t100.x0;
		dcfg->m[MX_POS].y0 = dcfg->t9_t100.y0;
		dcfg->m[MX_POS].x1 = 0;
		dcfg->m[MX_POS].y1 = 0;

		//aa relative retangle
		dcfg->m[MX_AA].x0 = 0;
		dcfg->m[MX_AA].y0 = 0;
		dcfg->m[MX_AA].x1 = dcfg->t9_t100.xsize - 1;
		dcfg->m[MX_AA].y1 = dcfg->t9_t100.ysize - 1;

		//touch aa relative retangle
		dcfg->m[MX_T].x0 = 0;
		dcfg->m[MX_T].y0 = 0;
		dcfg->m[MX_T].x1 = dcfg->t9_t100.xsize - 1;
		dcfg->m[MX_T].y1 = dcfg->t9_t100.ysize - 1;

		dcfg->m[MX_K].x0 = -1;
		dcfg->m[MX_K].y0 = -1;
		dcfg->m[MX_K].x1 = -1;
		dcfg->m[MX_K].y1 = -1;
	} else {
		//aa absolute position
		dcfg->m[MX_POS].x0 = min_t(int, dcfg->t15.x0, dcfg->t9_t100.x0);
		dcfg->m[MX_POS].y0 = min_t(int, dcfg->t15.y0, dcfg->t9_t100.y0);
		dcfg->m[MX_POS].x1 = 0;
		dcfg->m[MX_POS].y1 = 0;

		//aa relative retangle
		dcfg->m[MX_AA].x0 = 0;
		dcfg->m[MX_AA].y0 = 0;
		dcfg->m[MX_AA].x1 = dcfg->t9_t100.xsize - 1;
		if (dcfg->t15.x0 < dcfg->t9_t100.x0 || dcfg->t15.x0 > dcfg->t9_t100.x0 + dcfg->t9_t100.xsize - 1)
			dcfg->m[MX_AA].x1 += dcfg->t15.xsize;
		dcfg->m[MX_AA].y1 = dcfg->t9_t100.ysize - 1;
		if (dcfg->t15.y0 < dcfg->t9_t100.y0 || dcfg->t15.y0 > dcfg->t9_t100.y0 + dcfg->t9_t100.ysize - 1)
			dcfg->m[MX_AA].y1 += dcfg->t15.ysize;

		//touch aa relative retangle
		if (dcfg->t15.x0 < dcfg->t9_t100.x0) {
			dcfg->m[MX_T].x0 = dcfg->t9_t100.x0 - dcfg->t15.x0;
		} else {
			dcfg->m[MX_T].x0 = 0;
		}

		if (dcfg->t15.y0 < dcfg->t9_t100.y0) {
			dcfg->m[MX_T].y0 = dcfg->t9_t100.y0 - dcfg->t15.y0;
		} else {
			dcfg->m[MX_T].y0 = 0;
		}
		dcfg->m[MX_T].x1 = dcfg->m[MX_T].x0 + dcfg->t9_t100.xsize - 1;
		dcfg->m[MX_T].y1 = dcfg->m[MX_T].y0 + dcfg->t9_t100.ysize - 1;

		//key aa relative retangle
		if (dcfg->t15.x0 < dcfg->t9_t100.x0) {
			dcfg->m[MX_K].x0 = 0;
		} else {
			dcfg->m[MX_K].x0 = dcfg->t15.x0 - dcfg->t9_t100.x0;
		}

		if (dcfg->t15.y0 < dcfg->t9_t100.y0) {
			dcfg->m[MX_K].y0 = 0;
		} else {
			dcfg->m[MX_K].y0 = dcfg->t15.y0 - dcfg->t9_t100.y0;
		}
		dcfg->m[MX_K].x1 = dcfg->m[MX_K].x0 + dcfg->t15.xsize - 1;
		dcfg->m[MX_K].y1 = dcfg->m[MX_K].y0 + dcfg->t15.ysize - 1;
	}

	for (i = 0; i < MX_SUM; i++) {
		printk(KERN_INFO "[mxt]dcfg: Matrix %d (%d,%d)~(%d,%d)\n",
				i,
				dcfg->m[i].x0,
				dcfg->m[i].y0,
				dcfg->m[i].x1,
				dcfg->m[i].y1);
	}

	dcfg->s[SC].x = matrix_xsize;
	dcfg->s[SC].y = matrix_ysize;

	dcfg->s[SC_AA].x = dcfg->t9_t100.xsize;
	dcfg->s[SC_AA].y = dcfg->t9_t100.ysize;

	return 0;
}

static int mxt_diagnostic_command(struct mxt_data *data, u8 cmd, u8 page, u8 index, u8 num, char * buf, int interval, int interval_c)
{
	u16 reg;
	s8 command_register[2];
	s8 current_page,page_cmd;
	int ret;
	int timeout_counter,retry;

	long unsigned int time_start = jiffies;

	reg = data->T37_address;
	ret = __mxt_read_reg(data->client, reg, sizeof(command_register), &command_register[0]);
	if (ret) {
		dev_err(&data->client->dev, "T37 read offset 0 failed %d!\n",ret);
		return -EIO;
	}
#define T37_COMMAND_RESEND_INDEX  2
	if ((u8)command_register[0] != cmd || (page == 0 && index < T37_COMMAND_RESEND_INDEX)) {
		ret = mxt_t6_command(data, MXT_COMMAND_DIAGNOSTIC, cmd, 0);
		if (ret) {
			dev_err(&data->client->dev, "T6 Command DIAGNOSTIC cmd 0x%x failed %d!\n",cmd,ret);
			return -EIO;
		}
		current_page = 0;
	} else {
		current_page = command_register[1];
		if (abs((s8)current_page - (s8)page) > (s8)page) {// far away with dis page
			ret = mxt_t6_command(data, MXT_COMMAND_DIAGNOSTIC, cmd, 0);
			if  (ret) {
				dev_err(&data->client->dev, "T6 Command DIAGNOSTIC cmd 0x%x failed %d!\n",cmd,ret);
				return -EIO;
			}
			current_page = 0;
		}
	}

	//wait command
	timeout_counter = 0;
	do {	
		msleep(interval);
		reg = data->T37_address;
		ret = __mxt_read_reg(data->client, reg, sizeof(command_register), &command_register[0]);
		if (ret) {
			dev_err(&data->client->dev, "T37 read offset 0 failed %d!\n",ret);
			return -EIO;
		}

		if ((u8)command_register[0] == cmd)
			break;

		if (!interval_c)
			return -EAGAIN;

	} while (timeout_counter++ <= interval_c);

	if (timeout_counter > interval_c) {
		dev_err(&data->client->dev,
			"T37 wait cmd %d page %d current page %d timeout, T37 buf(%d %d) ##1\n",
			cmd,page,current_page,(u8)command_register[0],command_register[1]);
		return -EBUSY;
	}

	//current_page = command_register[1];
	retry = 0;
	while (current_page != page) {

		if (current_page > page) {
			page_cmd = MXT_T6_DEBUG_PAGEDOWN;
			current_page--;
		} else {
			page_cmd = MXT_T6_DEBUG_PAGEUP;
			current_page++;
		}

		time_start = jiffies;

		ret = mxt_t6_command(data, MXT_COMMAND_DIAGNOSTIC,page_cmd, 0);
		if (ret) {
			dev_err(&data->client->dev,
			"T6 Command DIAGNOSTIC page %d to page %d failed %d!\n",current_page,page,ret);
			return -EIO;
		}

		if (!interval_c)
			return -EAGAIN;

		//fix me: here need wait every cycle?
		timeout_counter = 0;
		do {
			reg = data->T37_address;
			ret = __mxt_read_reg(data->client, reg,
						sizeof(command_register), &command_register[0]);
			if (ret) {
				dev_err(&data->client->dev, "T37 read offset 0 failed %d!\n",ret);
				return -EIO;
			}
			if ((u8)command_register[0] != cmd) {
				break;
			}
			if (current_page == command_register[1])
				break;

			msleep(interval);
		} while (timeout_counter++ <= interval_c);

		if (timeout_counter > interval_c) {
			if (retry++ > interval_c) {
				dev_err(&data->client->dev,
					"T37 wait cmd %d page %d current page %d timeout, T37 buf(%d %d) page_cmd %d retry %d ##2\n",
					cmd,page,current_page,(u8)command_register[0],command_register[1],page_cmd,retry);
				return -EBUSY;
			}
		}
		if ((u8)command_register[0] != cmd) {
			dev_err(&data->client->dev,
				"T37 wait cmd %d page %d current page %d timeout, T37 buf(%d %d) ##3\n",
				cmd,page,current_page,(u8)command_register[0],command_register[1]);
			return -EBUSY;
		}
		current_page = command_register[1];

		dev_dbg(&data->client->dev, "T37 page command ticks %lu\n",jiffies - time_start);
	}

	if (buf) {
		ret = __mxt_read_reg(data->client, data->T37_address + sizeof(command_register) + index,
				num, buf);
		if (ret) {
			dev_err(&data->client->dev,
				"Failed to read T37 val at page %d.%d (%d)\n", page, index, ret);
			return -EIO;
		}

		//check the command again
		ret = __mxt_read_reg(data->client, reg, sizeof(command_register), &command_register[0]);
		if (ret) {
			dev_err(&data->client->dev, "T37 read offset 0 failed %d!\n",ret);
			return -EIO;
		} 

		if ((u8)command_register[0] != cmd || command_register[1] != page) {
			dev_err(&data->client->dev, "T37 page changed (%d,%d) -> (%d,%d)\n",
					cmd,
					page,
					(u8)command_register[0],
					command_register[1]);
			return -EIO;
		}
	}

	return 0;
}

static int mxt_diagnostic_command_fast_write(void *pl_dev, struct diagnostic_block *block, bool send)
{
	struct plug_interface *pl = pl_dev;
	struct mxt_data *data = pl->dev;
	struct device *dev = &data->client->dev;
	s8 current_page, step, step_p;
	int ret;

	struct reg_config reg = 
		{.reg = MXT_DEBUG_DIAGNOSTIC_T37,
			.offset = 0,.buf = {0}, .len = 2, .mask = 0, .flag = 0, .sleep = 0};
	struct reg_config t6_reg =
		{.reg = MXT_GEN_COMMANDPROCESSOR_T6,
			.offset = MXT_COMMAND_DIAGNOSTIC,.buf = {0}, .len = 1, .mask = 0, .flag = 0, .sleep = 0};

	ret = mxt_get_obj_cfg(pl_dev, &reg, 0);
	if (ret)
		return -EIO;

	if (reg.buf[0] != block->diag.cmd) {
		if (block->curr)
			return -EFAULT;
		else {
			t6_reg.buf[0] = block->diag.cmd;
		}
	} else {
		current_page = (s8)reg.buf[1];
		step = current_page -block->diag.page;
		step_p = block->step - block->curr + 1;

		if (step == 0) {
			if (!block->curr) {
				if (block->diag.page < 2)
					t6_reg.buf[0] = MXT_T6_DEBUG_PAGEUP;
				else
					t6_reg.buf[0] = block->diag.cmd;
			}
		}else {
			if ((abs(block->diag.page) + 1 < abs(step)))	// far away with dis page
				t6_reg.buf[0] = block->diag.cmd;
			else {
				if (step < 0)
					t6_reg.buf[0] = MXT_T6_DEBUG_PAGEUP;
				else
					t6_reg.buf[0] = MXT_T6_DEBUG_PAGEDOWN;
			}
		}
	}

	dev_dbg(dev, "Diagnostic (%x, %d, %d %d)  t37 (%x,%d) t6(%x) step (%d,%d,%d,%d)\n", 
		block->diag.cmd, block->diag.page, block->diag.index, block->diag.num, 
		reg.buf[0],  reg.buf[1], t6_reg.buf[0],
		block->curr,
		block->step,
		block->max_step,
		block->ext);

	if (t6_reg.buf[0]) {
		if (block->curr < block->max_step) {
			if (send) {
				ret = mxt_set_obj_cfg(pl_dev, &t6_reg, NULL, 0);
				if (ret)
					return -EIO;

				block->curr++;
			}
			return -EAGAIN;
		}else {
			return -ETIME;
		}
	}

	return 0;
}

static int mxt_diagnostic_command_fast_read(void *pl_dev,  struct diagnostic_block *block)
{
	struct plug_interface *pl = pl_dev;
	struct mxt_data *data = pl->dev;
	struct device *dev = &data->client->dev;
	int timeout;
	int ret;

	struct reg_config reg = 
		{.reg = MXT_DEBUG_DIAGNOSTIC_T37,
			.offset = 0,.buf = {0}, .len = 2, .mask = 0, .flag = 0, .sleep = 0};

	//fix me: here need wait every cycle?
	timeout = 0;
	do {
		ret = mxt_get_obj_cfg(pl_dev, &reg, 0);
		if (ret) {
			dev_err(dev, "Diagnostic command read: check command failed (%x, %d) ret %d\n",
				block->diag.cmd,block->diag.page, ret);
			return -EIO;
		}
		if (reg.buf[0] != block->diag.cmd) {
			break;
		}
		if ((s8)reg.buf[1] == block->diag.page)
			break;

		msleep(block->interval);
	} while (timeout++ <= block->count);

	if (timeout > block->count) {
		dev_err(dev, "Diagnostic command read: command (%x, %d) timeout, (%x,%d)\n",
			block->diag.cmd,block->diag.page,reg.buf[0] ,reg.buf[1]);
		return -EBUSY;
	}
	if (reg.buf[0]  != block->diag.cmd) {
		dev_err(dev, "Diagnostic command read: command (%x, %d) timeout, (%x,%d), cmd mismatch\n",
			block->diag.cmd,block->diag.page,reg.buf[0] ,reg.buf[1]);
		return -EBUSY;
	}

	if (block->buf) {
		reg.offset = block->diag.index + 2;
		reg.len = block->diag.num;
		reg.ext_buf = block->buf;
		ret = mxt_get_obj_cfg(pl_dev, &reg, FLAG_REG_DATA_IN_EXT_BUF);
		if (ret) {
			dev_err(dev, "Diagnostic command read: command (%x, %d) get data(%d) failed %d\n",
				block->diag.cmd,block->diag.page, reg.len, ret);
			return -EIO;
		}

		reg.offset = 0;
		reg.len = 2;
		ret = mxt_get_obj_cfg(pl_dev, &reg, 0);
		if (ret) {
			dev_err(dev, "Diagnostic command read: command (%x, %d) check failed, (%x,%d)\n",
				block->diag.cmd,block->diag.page,reg.buf[0] ,reg.buf[1]);		
			return -EIO;
		}else {
			if (reg.buf[0]  != block->diag.cmd ||
				(s8)reg.buf[1] != block->diag.page) {
				dev_warn(dev, "Diagnostic command read: command (%x, %d) check failed, (%x,%d) page changed\n",
					block->diag.cmd,block->diag.page,reg.buf[0] ,reg.buf[1]);		
				return -EBUSY;
			}
		}
	}

	return 0;
}

static int mxt_get_init_config_t8(struct mxt_data *data,struct t8_config *cfg)
{
	struct device *dev = &data->client->dev;
	int error;

	error = __mxt_read_reg(data->client, data->T8_address + MXT_T8_ATCHCALST,
			1, &cfg->atchcalst);
	if (error) {
		dev_err(dev, "Failed to read T8 ATCHCALST %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T8_address + MXT_T8_ATCHCALSTHR,
			1, &cfg->atchcalsthr);
	if (error) {
		dev_err(dev, "Failed to read T8 ATCHCALSTHR %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T8_address + MXT_T8_ATCHFRCCALTHR,
			1, &cfg->atchfrccalthr);
	if (error) {
		dev_err(dev, "Failed to read T8 ATCHFRCCALTHR %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T8_address + MXT_T8_ATCHFRCCALRATIO,
			1, &cfg->atchfrccalratio);
	if (error) {
		dev_err(dev, "Failed to read T8 ATCHFRCCALRATIO %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T8_address + MXT_T8_TCHAUTOCAL,
			1, &cfg->tchautocal);
	if (error) {
		dev_err(dev, "Failed to read T8 TCHAUTOCAL %d\n", error);
		return -EIO;
	}
	return 0;
}

static int mxt_get_init_config_t9(struct mxt_data *data,struct t9_t100_config *cfg)
{
	struct device *dev = &data->client->dev;
	int error;

	error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_XORIGN,
			1, &cfg->x0);
	if (error) {
		dev_err(dev, "Failed to read T9 XORIGN %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_YORIGN,
			1, &cfg->y0);
	if (error) {
		dev_err(dev, "Failed to read T9 YORIGN %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_XSIZE,
			1, &cfg->xsize);
	if (error) {
		dev_err(dev, "Failed to read T9 XSIZE %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_YSIZE,
			1, &cfg->ysize);
	if (error) {
		dev_err(dev, "Failed to read T9 YSIZE %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_TCHHR,
			1, &cfg->threshold);
	if (error) {
		dev_err(dev, "Failed to read T9 TCHHR %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_TCHHYST,
			1, &cfg->hysterisis);
	if (error) {
		dev_err(dev, "Failed to read T9 TCHHYST %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_NUMTOUCH,
			1, &cfg->num_touch);
	if (error) {
		dev_err(dev, "Failed to read T9 NUMTOUCH %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_MRGTHR,
			1, &cfg->merge_threshold);
	if (error) {
		dev_err(dev, "Failed to read T9 MRGTHR %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_MRGHYST,
			1, &cfg->merge_hysterisis);
	if (error) {
		dev_err(dev, "Failed to read T9 MRGHYST %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_DUALX_THLD,
			1, &cfg->dualx_threshold);
	if (error) {
		dev_err(dev, "Failed to read T9 DUALX_THLD %d\n", error);
		return -EIO;
	}

	cfg->internal_threshold = cfg->threshold >> 1;
	cfg->internal_hysterisis = cfg->hysterisis;

	return 0;
}

static int mxt_get_init_config_t100(struct mxt_data *data,struct t9_t100_config *cfg)
{
	struct device *dev = &data->client->dev;
	u8 val;
	int error;

	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_XORIGN,
			1, &cfg->x0);
	if (error) {
		dev_err(dev, "Failed to read T100 XORIGN %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_YORIGN,
			1, &cfg->y0);
	if (error) {
		dev_err(dev, "Failed to read T100 YORIGN %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_XSIZE,
			1, &cfg->xsize);
	if (error) {
		dev_err(dev, "Failed to read T100 XSIZE %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_YSIZE,
			1, &cfg->ysize);
	if (error) {
		dev_err(dev, "Failed to read T100 YSIZE %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_TCHHR,
			1, &cfg->threshold);
	if (error) {
		dev_err(dev, "Failed to read T100 TCHHR %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_TCHHYST,
			1, &cfg->hysterisis);
	if (error) {
		dev_err(dev, "Failed to read T100 TCHHYST %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_INTTHR,
		1, &cfg->internal_threshold);
	if (error) {
		dev_err(dev, "Failed to read T100 INTTHR %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_INTTHRHYST,
		1, &cfg->internal_hysterisis);
	if (error) {
		dev_err(dev, "Failed to read T100 INTTHRHYST %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_NUMTOUCH,
			1, &cfg->num_touch);
	if (error) {
		dev_err(dev, "Failed to read T100 NUMTOUCH %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_MRGTHR,
			1, &cfg->merge_threshold);
	if (error) {
		dev_err(dev, "Failed to read T100 MRGTHR %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_MRGHYST,
			1, &cfg->merge_hysterisis);
	if (error) {
		dev_err(dev, "Failed to read T100 MRGHYST %d\n", error);
		return -EIO;
	}
	error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_DXTHRSF,
			1, &val);
	if (error) {
		dev_err(dev, "Failed to read T100 DXTHRSF %d\n", error);
		return -EIO;
	}
	if (val == 0)
		val = 128;
	cfg->dualx_threshold = ((u32)cfg->threshold * val) >> 7;

	if (cfg->xsize == 0)
		cfg->xsize = 1;
	if (cfg->ysize == 0)
		cfg->ysize = 1;
	return 0;
}


static int mxt_get_init_config_t15(struct mxt_data *data,struct t15_config *cfg)
{
	struct device *dev = &data->client->dev;
	int error;
	u8 val;

	error = __mxt_read_reg(data->client, data->T15_address,
			1, &val);
	if (error) {
		dev_err(dev, "Failed to read T15 EN %d\n", error);
		return -EIO;
	}

	if (val & 0x1) { //enable
		error = __mxt_read_reg(data->client, data->T15_address + MXT_T15_XORIGN,
				1, &cfg->x0);
		if (error) {
			dev_err(dev, "Failed to read T15 XORIGN %d\n", error);
			return -EIO;
		}
		error = __mxt_read_reg(data->client, data->T15_address + MXT_T15_YORIGN,
				1, &cfg->y0);
		if (error) {
			dev_err(dev, "Failed to read T15 YORIGN %d\n", error);
			return -EIO;
		}
		error = __mxt_read_reg(data->client, data->T15_address + MXT_T15_XSIZE,
				1, &cfg->xsize);
		if (error) {
			dev_err(dev, "Failed to read T15 XSIZE %d\n", error);
			return -EIO;
		}
		error = __mxt_read_reg(data->client, data->T15_address + MXT_T15_YSIZE,
				1, &cfg->ysize);
		if (error) {
			dev_err(dev, "Failed to read T15 YSIZE %d\n", error);
			return -EIO;
		}
		error = __mxt_read_reg(data->client, data->T15_address + MXT_T15_TCHHR,
				1, &cfg->threshold);
		if (error) {
			dev_err(dev, "Failed to read T15 TCHHR %d\n", error);
			return -EIO;
		}
	} else {
		memset(cfg,0,sizeof(*cfg));
	}

	return 0;
}

static int mxt_get_init_config_common(struct mxt_data *data, u16 reg, u16 len, void *val)
{
	struct device *dev = &data->client->dev;
	int error;

	if (!reg)
		return 0;

	error = __mxt_read_reg(data->client, reg,
			len, val);
	if (error) {
		dev_err(dev, "Failed to read address %d error %d\n", reg, error);
		return -EIO;
	}

	return 0;
}

static int mxt_set_t6_cal(void *pl_dev)
{
	struct plug_interface *pl = pl_dev;
	struct mxt_data *data = pl->dev;

	return mxt_t6_command(data, MXT_COMMAND_CALIBRATE, 1, false);
}

static int mxt_set_t6(void *pl_dev,u16 cmd_offset, u8 value, bool wait)
{
	struct plug_interface *pl = pl_dev;
	struct mxt_data *data = pl->dev;

	return mxt_t6_command(data, cmd_offset, value, wait);
}

static int mxt_set_obj_cfg(void *pl_dev, struct reg_config *config, u8 *stack_buf, unsigned long flag)
{
	struct plug_interface *pl = pl_dev;
	struct mxt_data *data = pl->dev;
	struct device *dev = &data->client->dev;
	struct mxt_object *object;
	u16 reg;
	u8 old_buf[255],*buf;
	int ret;
	int i;
	
	dev_dbg(dev, "mxt set t%d offset %d, len %d mask 0x%lx, flag 0x%lx\n",
		config->reg,
		config->offset,
		config->len,
		config->mask,
		config->flag);

	if (test_flag(FLAG_REG_DATA_IN_EXT_BUF, &flag)) {
		dev_dbg(dev, "mxt set use ext buffer 0x%p len %d\n",
				config->ext_buf,config->len);
		buf = config->ext_buf;
	}else {
		buf = config->buf;
	}

	if (flag && config->flag) {
		if (!(flag & config->flag)) {
			dev_dbg2(dev, "Skip request: reg %d off %d len %d flag(0x%lx,0x%lx,0x%lx)\n",
				config->reg,config->offset,config->len,
				flag, config->flag, flag & config->flag);
			return 0;
		}
	}

	if (config->len == 0) {
		dev_dbg2(dev, "Skip zero request: reg %d off %d len %d\n",
			config->reg,config->offset,config->len);
		return 0;
	}
	object = mxt_get_object(data, config->reg);
	if (!object) {
		dev_err(dev, "Object not found: reg %d off %d len %d\n",
			config->reg,config->offset,config->len);
		return -ENODATA;
	}
	if (!object->start_address) {
		dev_err(dev, "Object address not found: reg %d off %d len %d\n",
			config->reg,config->offset,config->len);
		return -EINVAL;
	}
	if (object->instances_minus_one < config->instance) {
		dev_err(dev, "Tried to write outside object T%d instance %d not exist",
			config->reg,config->instance);
		return -EINVAL;
	}
	if (config->offset >= mxt_obj_size(object)) {
		dev_err(dev, "Tried to write outside object T%d"
			" offset:%d, size:%d\n", config->reg, config->offset, mxt_obj_size(object));
		return -EINVAL;
	}
	if (config->len > sizeof(old_buf)) {
		dev_err(dev, "Config data too long: reg %d off %d len %d\n",
			config->reg,config->offset,config->len);
		return -EINVAL;
	}

	reg = object->start_address + mxt_obj_size(object) * config->instance + config->offset;
	dev_dbg2(dev, "mxt set address %d\n",reg);
	if (stack_buf || config->mask) {
		ret = __mxt_read_reg(data->client, reg, config->len, old_buf);
		if (ret) {
			dev_err(dev, "Config read reg failed: reg %d off %d len %d\n",
				config->reg,config->offset,config->len);
			return ret;
		}
		if (config->mask) {
			for (i = 0; i < config->len; i++) {
				buf[i] &= config->mask;
				buf[i] |= old_buf[i] & ~config->mask;
			}
		}
	}

#if (DBG_LEVEL > 1)
	dev_info(dev, "mxt set t%d offset %d, len %d mask 0x%lx, flag 0x%lx\n",
		config->reg,
		config->offset,
		config->len,
		config->mask,
		config->flag);

	print_hex_dump(KERN_INFO, "[mxt]", DUMP_PREFIX_NONE, 16, 1,
			buf, config->len, false);
#endif
	ret = __mxt_write_reg(data->client, reg, config->len, buf);

	if (ret == 0) {
		if (stack_buf)
			memcpy(stack_buf, old_buf, config->len);
		if (config->sleep)
			msleep(config->sleep);
	}

	return ret;
}

static int mxt_get_obj_cfg(void *pl_dev, struct reg_config *config, unsigned long flag)
{
	struct plug_interface *pl = pl_dev;
	struct mxt_data *data = pl->dev;
	struct device *dev = &data->client->dev;
	struct mxt_object *object;
	u8 *buf;
	u16 reg;
	int ret;
	int i;
	
	dev_dbg(dev, "mxt get t%d ins %d offset %d, len %d mask 0x%lx, flag 0x%lx\n",
		config->reg,
		config->instance,
		config->offset,
		config->len,
		config->mask,
		config->flag);

	if (test_flag(FLAG_REG_DATA_IN_EXT_BUF, &flag)) {
		dev_dbg(dev, "mxt set use ext buffer 0x%p len %d\n",
				config->ext_buf,config->len);
		buf = config->ext_buf;
	}else {
		buf = config->buf;
		if (config->len > sizeof(config->buf))
			config->len = sizeof(config->buf);
	}
	memset(buf,0,config->len);

	if (flag && config->flag) {
		if (!(flag & config->flag)) {
			dev_dbg2(dev, "Skip request: reg %d off %d len %d flag(0x%lx,0x%lx,0x%lx)\n",
				config->reg,config->offset,config->len,
				flag, config->flag, flag & config->flag);
			return 0;
		}
	}

	object = mxt_get_object(data, config->reg);
	if (!object) {
		dev_err(dev, "Object not found: reg %d off %d len %d\n",
			config->reg,config->offset,config->len);
		return -ENODATA;
	}
	if (!object->start_address) {
		dev_err(dev, "Object address not found: reg %d off %d len %d\n",
			config->reg,config->offset,config->len);
		return -EINVAL;
	}
	if (object->instances_minus_one < config->instance) {
		dev_err(dev, "Tried to read outside object T%d instance %d not exist",
			config->reg,config->instance);
		return -EINVAL;
	}
	if (config->offset >= mxt_obj_size(object)) {
		dev_err(dev, "Tried to read outside object T%d"
			" offset:%d, size:%d\n", config->reg, config->offset, mxt_obj_size(object));
		return -EINVAL;
	}

	if (config->len) {
		reg = object->start_address + mxt_obj_size(object) * config->instance + config->offset;
		ret = __mxt_read_reg(data->client, reg, config->len, buf);
		if (ret) {
			dev_err(dev, "Config read reg failed: reg %d off %d len %d\n",
				config->reg,config->offset,config->len);
			return ret;
		}
		if (config->mask) {
			for (i = 0; i < config->len; i++) {
				buf[i] &= config->mask;
				buf[i] |= buf[i] & ~config->mask;
			}
		}
	}
	config->reg_len = mxt_obj_size(object);

#if (DBG_LEVEL > 1)
	dev_info(dev, "mxt get t%d ins %d offset %d, len %d mask 0x%lx, flag 0x%lx\n",
		config->reg,
		config->instance,
		config->offset,
		config->len,
		config->mask,
		config->flag);

	print_hex_dump(KERN_INFO, "[mxt]", DUMP_PREFIX_NONE, 16, 1,
			buf, config->len, false);
#endif

	return ret;
}

static int mxt_get_diagnostic_data(void *pl_dev, u8 cmd, u8 page, u8 index, u8 num, char * buf, int interval, int interval_c)
{
	struct plug_interface *pl = pl_dev;
	struct mxt_data *data = pl->dev;

	return mxt_diagnostic_command(data, cmd, page, index, num, buf, interval, interval_c);
}

static void mxt_plugin_hook_t6(struct plug_interface *pl, u8 status);
static void emu_mxt_plugin_hook_t6(void *pl, u8 status)
{
	mxt_plugin_hook_t6((struct plug_interface *)pl, status);
}

static int mxt_set_reset(void *pl_dev, int por)
{
	struct plug_interface *pl = pl_dev;
	struct mxt_data *data = pl->dev;
	const struct mxt_platform_data *pdata = data->pdata;
	struct device *dev = &data->client->dev;
	struct reg_config t6_reset =
		{.reg = MXT_GEN_COMMANDPROCESSOR_T6,
			.offset = 0,.buf = {0x1}, .len = 1, .mask = 0, .flag = 0, .sleep = MXT_RESET_TIME};
	int ret = -EBUSY;

	if (por) {
		dev_info(dev, "mxt set reset #3 (POR)\n");
		ret = board_por_reset(data, data);
	}

	if (ret) {
		//hardware reset or soft reset, return 0 if success 
		dev_info(dev, "mxt set reset #2 (HW)\n");
		ret = board_hw_reset(pdata);
	}

	if (ret) {
		dev_info(dev, "mxt set reset #1 (SOFT)\n");
		ret = mxt_set_obj_cfg(pl_dev, &t6_reset, NULL, 0);
	}

	return ret;
}

#if defined(CONFIG_MXT_T71_RESET_WATCHDOG)
static int mxt_check_rst_result(struct plug_interface *pl, bool mark_tag)
{
	struct mxt_data *data = pl->dev;
	struct device *dev = &data->client->dev;
	u8 val;
	int ret = 0;

	if (!data->T71_address)
		return ret;

	ret = __mxt_read_reg(data->client, data->T71_address + MXT_T71_RESET_TAG,
		sizeof(val), &val);
	if (ret) {
		dev_err(dev, "Failed to read T71 byte reset tag, ret %d\n", ret);
		return ret;
	}

	if (val == 0) {
		if (mark_tag) {
			val = MXT_T71_RESET_MAGIC_WORD;
			__mxt_write_reg(data->client, data->T71_address + MXT_T71_RESET_TAG,
				sizeof(val), &val);
			//here don't check write result, or you should avoid loop-in reset
		}
	}else{
		dev_err(dev, "Read T71 reset val 0x%x(tag %x)\n", val,mark_tag);
		if(val == MXT_T71_RESET_MAGIC_WORD)  //don't use watchdog if T71 has some other value
			ret = -EINVAL;
	}

	return ret;
}

static int mxt_check_t9_t100_ctrl(struct plug_interface *pl,bool reset_if_disable)
{
	struct mxt_data *data = pl->dev;
	struct device *dev = &data->client->dev;
	int error;
	u8 ctrl = T9_T100_CTRL_ENABLE | T9_T100_CTRL_REPEN;

	error = 0;
	if (data->T9_address) {
		error = __mxt_read_reg(data->client, data->T9_address + MXT_T9_CTRL,
				1, &ctrl);
	} else if (data->T100_address) {
		error = __mxt_read_reg(data->client, data->T100_address + MXT_T100_CTRL,
				1, &ctrl);
	}

	if (error) {
		dev_err(dev, "Failed to read T9/T100 CTRL %d\n", error);
		return -EIO;
	}

	if ((ctrl & (T9_T100_CTRL_ENABLE | T9_T100_CTRL_REPEN)) != (T9_T100_CTRL_ENABLE | T9_T100_CTRL_REPEN)) {
		dev_err(dev, "T9/T100 CTRL error 0x%x\n", ctrl);
		if (reset_if_disable) 
			return mxt_set_reset(pl, 0);
		return -EINVAL;
	}

	return 0;
}
#endif

static int mxt_get_init_cfg(struct mxt_data *data)
{
	struct device *dev = &data->client->dev;
	struct plug_interface *pl = &data->plug;
	struct mxt_config *dcfg = &pl->init_cfg;
	int error;

	//read t7 parameter

	error = mxt_get_init_config_common(data, data->T7_address, sizeof(dcfg->t7),&dcfg->t7);
	if (error) {
		dev_err(dev, "Failed to read T7 parameter %d\n", error);
		return -EIO;
	}

	//read t8 parameter
	error = mxt_get_init_config_t8(data,&dcfg->t8);
	if (error) {
		dev_err(dev, "Failed to read T8 parameter %d\n", error);
		return -EIO;
	}
	//read t9 parameter
	if (data->T9_reportid_min) {
		error = mxt_get_init_config_t9(data,&dcfg->t9_t100);
		if (error) {
			dev_err(dev, "Failed to read T9 parameter %d\n", error);
			return -EIO;
		}
	}

	//read t100 parameter
	if (data->T100_reportid_min) {
		error = mxt_get_init_config_t100(data,&dcfg->t9_t100);
		if (error) {
			dev_err(dev, "Failed to read T100 parameter %d\n", error);
			return -EIO;
		}
	}

	//read t15 parameter
	if (data->T15_reportid_min) {
		error = mxt_get_init_config_t15(data,&dcfg->t15);
		if (error) {
			dev_err(dev, "Failed to read T15 parameter %d\n", error);
			return -EIO;
		}
	}
	//read t38 parameter
	error =  mxt_get_init_config_common(data, data->T38_address, sizeof(dcfg->t38),&dcfg->t38);
	if (error) {
		dev_err(dev, "Failed to read T38 parameter %d\n", error);
		return -EIO;
	}

	//read t40 parameter
	error =  mxt_get_init_config_common(data, data->T40_address, sizeof(dcfg->t40),&dcfg->t40);
	if (error) {
		dev_err(dev, "Failed to read T40 parameter %d\n", error);
		return -EIO;
	}
	//read t42 parameter
	error =  mxt_get_init_config_common(data, data->T42_address, sizeof(dcfg->t42),&dcfg->t42);
	if (error) {
		dev_err(dev, "Failed to read T42 parameter %d\n", error);
		return -EIO;
	}

	//read t55 parameter
	error =  mxt_get_init_config_common(data, data->T55_address, sizeof(dcfg->t55),&dcfg->t55);
	if (error) {
		dev_err(dev, "Failed to read T55 parameter %d\n", error);
		return -EIO;
	}

	//read t61 parameter
	error =  mxt_get_init_config_common(data, data->T61_address, sizeof(dcfg->t61),&dcfg->t61);
	if (error) {
		dev_err(dev, "Failed to read T61 parameter %d\n", error);
		return -EIO;
	}

	//read t65 parameter
	error =  mxt_get_init_config_common(data, data->T65_address, sizeof(dcfg->t65),&dcfg->t65);
	if (error) {
		dev_err(dev, "Failed to read T65 parameter %d\n", error);
		return -EIO;
	}
	
	//read t80 parameter
	error =  mxt_get_init_config_common(data, data->T80_address, sizeof(dcfg->t80),&dcfg->t80);
	if (error) {
		dev_err(dev, "Failed to read T80 parameter %d\n", error);
		return -EIO;
	}
	//read t92 parameter
	error =  mxt_get_init_config_common(data, data->T92_address, sizeof(dcfg->t92),&dcfg->t92);
	if (error) {
		dev_err(dev, "Failed to read T92 parameter %d\n", error);
		return -EIO;
	}

	//read t96 parameter
	error =  mxt_get_init_config_common(data, data->T96_address, sizeof(dcfg->t96),&dcfg->t96);
	if (error) {
		dev_err(dev, "Failed to read T96 parameter %d\n", error);
		return -EIO;
	}

	//read t104 parameter
	error =  mxt_get_init_config_common(data, data->T104_address, sizeof(dcfg->t104),&dcfg->t104);
	if (error) {
		dev_err(dev, "Failed to read T104 parameter %d\n", error);
		return -EIO;
	}

	//read t113 parameter
	error =  mxt_get_init_config_common(data, data->T113_address, sizeof(dcfg->t113),&dcfg->t113);
	if (error) {
		dev_err(dev, "Failed to read T113 parameter %d\n", error);
		return -EIO;
	}

	config_matrix_init(dcfg,data->info->matrix_xsize,data->info->matrix_ysize);
	dcfg->dev = &data->client->dev;
	dcfg->max_x = data->max_x;
	dcfg->max_y = data->max_y;

	return 0;
}

static int mxt_get_phone_status(struct plug_interface *pl, unsigned long pl_flag)
{
	//phone on return -EBUSY, else return 0
	
	/*
	if (g_phone_on) {
		return -EBUSY;
	}
	*/
	return 0;
}

static void mxt_plugin_pre_process(struct plug_interface *pl, bool in_boot)
{
	struct plug_observer *obs = &pl->observer;
	
	if (!pl->inited)
		return;

	if (test_flag(PL_STATUS_FLAG_FORCE_STOP,&obs->flag)) {
		set_and_clr_flag(PL_STATUS_FLAG_STOP, PL_STATUS_FLAG_FORCE_STOP, &obs->flag);
		return;
	}

	if (test_flag(PL_STATUS_FLAG_STOP|PL_STATUS_FLAG_PAUSE|PL_STATUS_FLAG_SUSPEND,&obs->flag))
		return;

	if (!in_boot) {
		if (mxt_get_phone_status(pl, pl->observer.flag) == -EBUSY) {
			set_flag(PL_STATUS_FLAG_PHONE_ON,&obs->flag);
		}else{
			clear_flag(PL_STATUS_FLAG_PHONE_ON,&obs->flag);
		}

		if (test_flag(PL_STATUS_FLAG_PLUG_CAL,&obs->flag)) {
			if (pl->ac->pre_process)
				pl->ac->pre_process(pl->ac, pl->observer.flag);
			if (pl->cal->pre_process)
				pl->cal->pre_process(pl->cal, pl->observer.flag);
		}

		if (test_flag(PL_STATUS_FLAG_PLUG_PI,&obs->flag)) {
			if (pl->pi->pre_process)
				pl->pi->pre_process(pl->pi, pl->observer.flag);
		}

		if (test_flag(PL_STATUS_FLAG_PLUG_MSC,&obs->flag)) {
			if (pl->msc->pre_process)
				pl->msc->pre_process(pl->msc, pl->observer.flag);
		}

		if (test_flag(PL_STATUS_FLAG_PLUG_CLIP,&obs->flag)) {
			if (pl->clp->pre_process)
				pl->clp->pre_process(pl->clp, pl->observer.flag);
		}

		if (test_flag(PL_STATUS_FLAG_PLUG_WDG,&obs->flag)) {
			if (pl->wd->pre_process)
				pl->wd->pre_process(pl->wd, pl->observer.flag);
		}		
	}
}

static long mxt_plugin_post_process(struct plug_interface *pl, bool in_boot)
{
	struct plug_observer *obs = &pl->observer;
	unsigned long interval0,interval1;
#if defined(CONFIG_MXT_T71_RESET_WATCHDOG)
	struct plug_config *cfg = &pl->config;
	int ret;
#endif
	if (!pl->inited)
		return MAX_SCHEDULE_TIMEOUT;

	if (test_flag(PL_STATUS_FLAG_FORCE_STOP,&obs->flag)) {
		set_and_clr_flag(PL_STATUS_FLAG_STOP, PL_STATUS_FLAG_FORCE_STOP, &obs->flag);
		return MAX_SCHEDULE_TIMEOUT;
	}

	if (test_flag(PL_STATUS_FLAG_STOP|PL_STATUS_FLAG_PAUSE|PL_STATUS_FLAG_SUSPEND,&obs->flag))
		return MAX_SCHEDULE_TIMEOUT;
	
	interval0 = interval1 = MAX_SCHEDULE_TIMEOUT;
	if (!in_boot) {
#if defined(CONFIG_MXT_T71_RESET_WATCHDOG)
		if (test_flag(PL_STATUS_FLAG_PLUG_MSC,&obs->flag) ||
			test_flag(PL_STATUS_FLAG_PLUG_CAL,&obs->flag) ||
			test_flag(PL_STATUS_FLAG_PLUG_PI,&obs->flag) ||
			test_flag(PL_STATUS_FLAG_PLUG_CLIP,&obs->flag) ) {
			if (test_flag(PL_STATUS_FLAG_NEED_RESET,&obs->flag)) {
				if (mxt_set_reset((void *)pl, 0) == 0)
					clear_flag(PL_STATUS_FLAG_NEED_RESET,&obs->flag);
			}else if (test_flag(PL_STATUS_FLAG_RESET_END,&obs->flag)) {
				if (time_after_eq(jiffies, obs->time_reset_check_st + cfg->interval_reset_check_wait)) {
					ret = mxt_check_rst_result(pl, true);
					if (ret == 0)
						ret = mxt_check_t9_t100_ctrl(pl, false);
					if (ret == 0) {
						clear_flag(PL_STATUS_FLAG_RESET_END,&obs->flag);
					}else if (ret == -EINVAL) {
						set_flag(PL_STATUS_FLAG_NEED_RESET,&obs->flag);
						interval0 = cfg->interval_reset_check_wait;
					}else {
						//... I/O access error
					}
				}else {
					interval0 = obs->time_reset_check_st + cfg->interval_reset_check_wait - jiffies;
				}
			}
		}
#endif
		if (test_flag(PL_STATUS_FLAG_PLUG_CAL,&obs->flag)) {
			if (pl->ac->post_process) {
				interval1 = pl->ac->post_process(pl->ac, pl->observer.flag);
				interval0 = min_t(unsigned long,interval0,interval1);
			}
			if (pl->cal->post_process) {
				interval1 = pl->cal->post_process(pl->cal, pl->observer.flag);
				interval0 = min_t(unsigned long,interval0,interval1);
			}
		}
		
		if (test_flag(PL_STATUS_FLAG_PLUG_PI,&obs->flag)) {
			if (pl->pi->post_process) {
				interval1 = pl->pi->post_process(pl->pi, pl->observer.flag);
				interval0 = min_t(unsigned long,interval0,interval1);
			}
		}
		if (test_flag(PL_STATUS_FLAG_PLUG_MSC,&obs->flag)) {
			if (pl->msc->post_process) {
				interval1 = pl->msc->post_process(pl->msc, pl->observer.flag);
				interval0 = min_t(unsigned long,interval0,interval1);
			}
		}
		if (test_flag(PL_STATUS_FLAG_PLUG_CLIP,&obs->flag)) {
			if (pl->clp->post_process) {
				interval1 = pl->clp->post_process(pl->clp, pl->observer.flag);
				interval0 = min_t(unsigned long,interval0,interval1);
			}
		}

		if (test_flag(PL_STATUS_FLAG_PLUG_WDG,&obs->flag)) {
			if (pl->wd->post_process) {
				interval1 = pl->wd->post_process(pl->wd, pl->observer.flag);
				interval0 = min_t(unsigned long,interval0,interval1);
			}
		}
	}
	return min_t(unsigned long,interval0,interval1);
}

static void mxt_plugin_hook_t6(struct plug_interface *pl, u8 status)
{
	struct plug_observer *obs = &pl->observer;
#if defined(CONFIG_MXT_T71_RESET_WATCHDOG)
	int ret = 0;
#endif
	if (!pl->inited)
		return;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return;

	if (status) {
		set_flag(PL_STATUS_FLAG_NOSUSPEND, &pl->observer.flag);
		if (status & MXT_T6_STATUS_RESET) {
#if defined(CONFIG_MXT_T71_RESET_WATCHDOG)
			obs->time_reset_check_st = jiffies;
			ret = mxt_check_rst_result(pl, false);
			if (ret) {
				msleep(50);
				ret = mxt_check_rst_result(pl, false);
			}
			if(ret)
				return;
#endif
			set_and_clr_flag(PL_STATUS_FLAG_RESETING, PL_STATUS_FLAG_LOW_MASK, &pl->observer.flag);
		}
	}else {
		clear_flag(PL_STATUS_FLAG_NOSUSPEND, &pl->observer.flag);
		if (test_flag(PL_STATUS_FLAG_RESETING, &pl->observer.flag)) {
			set_and_clr_flag(PL_STATUS_FLAG_RESET_END, PL_STATUS_FLAG_RESETING, &pl->observer.flag);
		}
	}
	if (pl->cal->hook_t6)
		pl->cal->hook_t6(pl->cal, status);

	if (pl->ac->hook_t6)
		pl->ac->hook_t6(pl->ac, status);

	if (pl->pi->hook_t6)
		pl->pi->hook_t6(pl->pi, status);

	if (pl->msc->hook_t6)
		pl->msc->hook_t6(pl->msc, status);

	if (pl->clp->hook_t6)
		pl->clp->hook_t6(pl->clp, status);

	if (pl->wd->hook_t6)
		pl->wd->hook_t6(pl->wd, status);
}

static int mxt_plugin_hook_t42(struct plug_interface *pl, u8 status)
{
	struct plug_observer *obs = &pl->observer;
	int ret = 0;
	
	if (!pl->inited)
		return 0;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return 0;

	if (pl->cal->hook_t42)
		pl->cal->hook_t42(pl->cal, status);
 
	return ret;
}

/*
static int mxt_plugin_hook_t24(struct plug_interface *pl, u8 *msg)
{
	struct plug_observer *obs = &pl->observer;
	int ret = -EINVAL;
	
	if (!pl->inited)
		return ret;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return ret;

	if (pl->pi->hook_t24)
		ret = pl->pi->hook_t24(pl->pi, msg, obs->flag);

	return ret;
}
*/

static void mxt_plugin_hook_t61(struct plug_interface *pl, int id, u8 status)
{
	struct plug_observer *obs = &pl->observer;

	if (!pl->inited)
		return;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return;

	if (test_flag(PL_STATUS_FLAG_PLUG_WDG,&obs->flag)) {
		if (pl->wd->hook_t61)
			pl->wd->hook_t61(pl->wd, id, status);
	}
}

static void mxt_plugin_hook_t68(struct plug_interface *pl, u8* msg)
{
	struct plug_observer *obs = &pl->observer;

	if (!pl->inited)
		return;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return;

	if (pl->msc->hook_t68)
		pl->msc->hook_t68(pl->msc, msg);
}

static void mxt_plugin_hook_t72(struct plug_interface *pl, u8* msg)
{
	struct plug_observer *obs = &pl->observer;

	if (!pl->inited)
		return;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return;

	if (pl->ac->hook_t72)
		pl->ac->hook_t72(pl->ac, msg);
}

static void mxt_plugin_hook_reset_slots(struct plug_interface *pl)
{
	struct plug_observer *obs = &pl->observer;

	if (!pl->inited)
		return;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return;

	if (pl->cal->hook_reset_slots)
		pl->cal->hook_reset_slots(pl->cal);

	if (pl->clp->hook_reset_slots)
		pl->clp->hook_reset_slots(pl->clp);
}

static int mxt_plugin_hook_t9(struct plug_interface *pl, int id, int x, int y, u8 *info)
{
	struct plug_observer *obs = &pl->observer;
	int ret = 0;

	if (!pl->inited)
		return ret;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return ret;

	if (pl->cal->hook_t9)
		pl->cal->hook_t9(pl->cal, id, x, y, info[0]);

	if (test_flag(PL_STATUS_FLAG_PLUG_CLIP,&obs->flag)) {
		if (pl->clp->hook_t9)
			ret = pl->clp->hook_t9(pl->clp, id, x, y, info);
	}

	return ret;
}

static int mxt_plugin_hook_t100(struct plug_interface *pl, int id, int x, int y, struct ext_info *in)
{
	struct plug_observer *obs = &pl->observer;
	int ret = 0;
	
	if (!pl->inited)
		return ret;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return ret;

	if (pl->cal->hook_t100)
		pl->cal->hook_t100(pl->cal, id, x, y, in);

	if (test_flag(PL_STATUS_FLAG_PLUG_CLIP,&obs->flag)) {
		if (pl->clp->hook_t100)
			ret = pl->clp->hook_t100(pl->clp, id, x, y, in);
	}

	return ret;
}

static int mxt_plugin_hook_t100_scraux(struct plug_interface *pl, struct scr_info *in)
{
	struct plug_observer *obs = &pl->observer;
	int ret = 0;
	
	if (!pl->inited)
		return ret;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return ret;

	if (pl->cal->hook_t100_scraux)
		ret = pl->cal->hook_t100_scraux(pl->cal, in);

	if (test_flag(PL_STATUS_FLAG_PLUG_CLIP,&obs->flag)) {
		if (pl->clp->hook_t100_scraux)
			ret = pl->clp->hook_t100_scraux(pl->clp, in);
	}

	return ret;
}

static int mxt_plugin_hook_set_t7(struct plug_interface *pl, bool sleep)
{
	struct plug_observer *obs = &pl->observer;
	struct mxt_data *data;
	struct device *dev;

	int wait = 10;

	if (!pl->inited)
		return 0;

	data = pl->dev;
	dev = &data->client->dev;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return 0;

	if (sleep) {
		do{
			if (!(test_flag(PL_STATUS_FLAG_NOSUSPEND,&obs->flag)))
				break;

			dev_info(dev, "mxt_plugin_hook_set_t7 wait flag 0x%lx, wait %d\n", 
				obs->flag, wait);
				
			msleep(5);
		}while(--wait >= 0);

		if (test_flag(PL_STATUS_FLAG_NOSUSPEND,&obs->flag))
			return -EACCES;
	}

	return 0;
}

static int mxt_plugin_hook_gesture_msg(struct plug_interface *pl, u8 type, u8 *msg)
{
	struct plug_observer *obs = &pl->observer;
	ges_hook_callback fn_hook = NULL;
	int  ret = -EINVAL;

	if (!pl->inited)
		return ret;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return ret;

	switch(type){
	case MXT_PROCI_ONETOUCHGESTUREPROCESSOR_T24:
		fn_hook = pl->pi->hook_t24;
	break;
	case MXT_PROCI_TOUCHSUPPRESSION_T42:
		ret = 0;
	break;
	case MXT_SPT_TIMER_T61:
		fn_hook = pl->pi->hook_t61;
	break;
	case MXT_PROCI_UNLOCKGESTURE_T81:
		fn_hook = pl->pi->hook_t81;
	break;
	case MXT_PROCI_GESTURE_T92:
		fn_hook = pl->pi->hook_t92;
	break;
	case MXT_PROCI_TOUCHSEQUENCELOGGER_T93:
		fn_hook = pl->pi->hook_t93;
	break;
	case MXT_PROCI_KEYGESTUREPROCESSOR_T99:
		fn_hook = pl->pi->hook_t99;
	break;	
	case MXT_PROCI_SYMBOLGESTURE_T115:
		fn_hook = pl->pi->hook_t115;
	break;
	case MXT_SPT_SYMBOLGESTURECONFIG_T116:
		fn_hook = pl->pi->hook_t116;
	break;
	default:
		;
	}

	if (fn_hook)
		ret = fn_hook(pl->pi, msg, obs->flag);

	return ret;
}

static void mxt_plugin_active_thread(void *pl_dev)
{
	struct plug_interface *pl = (struct plug_interface *)pl_dev;

	if (pl) {
		if (pl->active_thread)
			pl->active_thread(pl->dev,MXT_EVENT_EXTERN);
	}
}

static int mxt_plugin_hook_reg_init(struct plug_interface *pl, u8 *config_mem, size_t config_mem_size, int cfg_start_ofs)
{
	struct mxt_data *data;	
	struct plug_observer *obs = &pl->observer;
	struct device *dev;
	size_t len;

	//we only need plugin is pre-inited
	data = pl->dev;
	if (!data)	
		return -ENODEV;

	dev = &data->client->dev;
	len = len;

	dev_info(dev, "mxt_plugin_hook_reg_init\n");
	set_flag(PL_STATUS_FLAG_REG_INIT,&obs->flag);

#if defined(CONFIG_MXT_T38_SKIP_LEN_AT_UPDATING)
	if (data->T38_address < cfg_start_ofs) {
		dev_err(dev, "Bad T8 address, T8addr = %x, config offset %x\n",
			data->T7_address, cfg_start_ofs);
		return -EINVAL;
	} else {
		len = min_t(int, config_mem_size, CONFIG_MXT_T38_SKIP_LEN_AT_UPDATING);
		len = min_t(int, len, sizeof(pl->init_cfg.t38.data));
		memcpy(config_mem + data->T38_address - cfg_start_ofs, pl->init_cfg.t38.data, len);
	}
#endif

	return 0;
}

static int mxt_plugin_hook_reg_access(struct plug_interface *pl, u16 addr, u16 reg, u16 len, const void *val, unsigned long flag, int result, bool is_w)
{
	struct plug_observer *obs = &pl->observer;
	int ret = result;

	if (!pl->inited)
		return ret;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return ret;

	if (test_flag(PL_STATUS_FLAG_PLUG_WDG,&obs->flag)) {
		if (pl->wd->hook_reg_access)
			ret = pl->wd->hook_reg_access(pl->wd, addr, reg, len, val, flag, result, is_w);
	}

	return ret;
}

static int mxt_plugin_cal_t37_check_and_calibrate(struct plug_interface *pl, bool check_sf, bool resume)
{
	int ret = -EBUSY;

	if (!pl->inited)
		return -ENODEV;

	if (pl->cal->check_and_calibrate)
		ret = pl->cal->check_and_calibrate(pl->cal, check_sf ,resume, pl->observer.flag);
	return ret;
}

static int mxt_plugin_wakeup_enable(struct plug_interface *pl)
{
	struct plug_observer *obs = &pl->observer;
	int ret = 0;

	if (!pl->inited)
		return 0;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return 0;

	if (test_flag(PL_STATUS_FLAG_PLUG_PI,&obs->flag)) {
		if (pl->pi->wake_enable)
			ret = pl->pi->wake_enable(pl->pi, obs->flag);
	}
	return ret;
}

static int mxt_plugin_wakeup_disable(struct plug_interface *pl)
{
	struct plug_observer *obs = &pl->observer;
	int ret = 0;

	if (!pl->inited)
		return 0;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return 0; 

	if (test_flag(PL_STATUS_FLAG_PLUG_PI,&obs->flag)) {
		if (pl->pi->wake_disable)
			ret = pl->pi->wake_disable(pl->pi, obs->flag);
			
	}
	return ret;
}

static int mxt_plugin_start(struct plug_interface *pl, bool resume)
{
	struct plug_observer *obs = &pl->observer;
	int ret = 0;

	if (!pl->inited)
		return 0;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return 0;

	if (resume) {
		set_and_clr_flag(PL_STATUS_FLAG_RESUME|PL_STATUS_FLAG_POWERUP,PL_STATUS_FLAG_SUSPEND, &obs->flag);
#if defined(CONFIG_MXT_T71_RESET_WATCHDOG)
		if(test_flag(PL_STATUS_FLAG_PLUG_PI,&obs->flag) &&
			test_flag(PL_FUNCTION_FLAG_WAKEUP,&obs->flag))
			mxt_check_t9_t100_ctrl(pl,true);
#endif
	} else
		clear_flag(PL_STATUS_FLAG_PAUSE, &obs->flag);

	if (pl->cal->start)
		pl->cal->start(pl->cal,resume);

	if (pl->ac->start)
		pl->ac->start(pl->ac,resume);

	if (pl->pi->start)
		pl->pi->start(pl->pi,resume);

	if (pl->msc->start)
		pl->msc->start(pl->msc,resume);

	if (pl->wd->start)
		pl->wd->start(pl->wd,resume);

	if (resume)
		clear_flag(PL_STATUS_FLAG_RESUME, &obs->flag);

	return ret;
}

static int mxt_plugin_stop(struct plug_interface *pl, bool suspend)
{
	struct plug_observer *obs = &pl->observer;
	int ret = 0;

	if (!pl->inited)
		return 0;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return 0;
		
	if (suspend) {
#if defined(CONFIG_MXT_TRIGGER_PI_PRE_PROCESS_AT_FIRST_POWERUP)
		//extern varible to control plugin
		if (test_flag(PL_STATUS_FLAG_PLUG_PI,&obs->flag) ||
			!test_flag(PL_STATUS_FLAG_POWERUP,&obs->flag)) {
			if (pl->pi->pre_process)
				pl->pi->pre_process(pl->pi, pl->observer.flag);
		}
#endif
		set_and_clr_flag(PL_STATUS_FLAG_SUSPEND, PL_STATUS_FLAG_RESUME, &obs->flag);
	}

	if (pl->wd->stop)
		pl->wd->stop(pl->wd);

	if (pl->cal->stop)
		pl->cal->stop(pl->cal);

	if (pl->ac->stop)
		pl->ac->stop(pl->ac);

	if (pl->pi->stop)
		pl->pi->stop(pl->pi);

	if (pl->msc->stop)
		pl->msc->stop(pl->msc);

	if (!suspend)
		set_flag(PL_STATUS_FLAG_PAUSE, &obs->flag);

	return ret;
}

static int mxt_plugin_force_stop(struct plug_interface *pl)
{
	struct mxt_data *data;
	struct device *dev;
	struct plug_observer *obs;
	int wait = 25;

	if (!pl->inited)
		return 0;

	data = pl->dev;
	dev = &data->client->dev;
	obs = &pl->observer;

	dev_info(dev, "mxt_plugin_force_stop\n");

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return 0;
		
	set_flag(PL_STATUS_FLAG_FORCE_STOP,&obs->flag);

	if (pl->active_thread)
		pl->active_thread(pl->dev,MXT_EVENT_EXTERN);

	do{
		if (test_flag(PL_STATUS_FLAG_CAL_END|PL_STATUS_FLAG_PAUSE,&obs->flag)) {
			set_and_clr_flag(PL_STATUS_FLAG_STOP, PL_STATUS_FLAG_FORCE_STOP, &obs->flag);
			return 0;
		}
	
		if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
			return 0;

		dev_info(dev, "mxt_plugin_force_stop wait flag 0x%lx, wait %d\n", obs->flag, wait);
			
		msleep(100);
	}while(--wait >= 0);

	set_and_clr_flag(PL_STATUS_FLAG_STOP, PL_STATUS_FLAG_FORCE_STOP, &obs->flag);
	return -EBUSY;
}

int mxt_plugin_get_pid_name(struct plug_interface *pl, char *name, int len)
{
	struct plug_observer *obs = &pl->observer;
	int ret = -ENODEV;

	if (!pl->inited)
		return ret;

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return ret;

	if (pl->msc->get_pid_name)
		ret = pl->msc->get_pid_name(pl->msc, name, len);

	return ret;
}

struct list_head * create_new_node(struct list_head *head, int node_size)
{
	struct list_head *n;

	n = kzalloc(node_size,GFP_KERNEL);
	if (n) {
		INIT_LIST_HEAD(n);
		list_add_tail(n,head);
	}

	printk(KERN_INFO "[mxt] create new node: head %p(%p,%p) node %p(%p,%p)\n",
		head,head->prev,head->next,
		n,n->prev,n->next);

	return n;
};

bool valid_config(const void *pcfg, int len, u8 check_val)
{
	u8 *dt = (u8 *)pcfg;
	int i;

	for (i = 0; i < len; i++) {
		if (dt[i] != check_val)
			return true;
	}

	return false;
}

static void mxt_plugin_thread_stopped(struct plug_interface *pl)
{
	struct mxt_data *data;
	struct device *dev;
	struct plug_observer *obs;

	if (!pl->inited)
		return;

	data = pl->dev;
	dev = &data->client->dev;
	obs = &pl->observer;

	dev_info(dev, "mxt_plugin_thread_stopped\n");

	if (test_flag(PL_STATUS_FLAG_STOP,&obs->flag))
		return;

	set_and_clr_flag(PL_STATUS_FLAG_FORCE_STOP, PL_STATUS_FLAG_STOP, &obs->flag);
}
static int init_plugin(struct plug_interface *pl)
{
	struct plug_observer *obs = &pl->observer;

#if defined(CONFIG_MXT_T71_RESET_WATCHDOG)
	struct plug_config *cfg = &pl->config;

	cfg->interval_reset_check_wait = HZ * 3 / 4;
#endif
#if defined(CONFIG_MXT_CAL_WORKAROUND)
	plugin_interface_cal_init(pl->cal);
#endif
#if defined(CONFIG_MXT_AC_WORKAROUND)
	plugin_interface_ac_init(pl->ac);
#endif
#if defined(CONFIG_MXT_PI_WORKAROUND)
	plugin_interface_proci_init(pl->pi);
#endif
#if defined(CONFIG_MXT_MISC_WORKAROUND)
	plugin_interface_misc_init(pl->msc);
#endif
#if defined(CONFIG_MXT_CLIP_WORKAROUND)
	plugin_interface_clip_init(pl->clp);
#endif
#if defined(CONFIG_MXT_WDG_WORKAROUND)
	plugin_interface_wdg_init(pl->wd);
#endif
	set_and_clr_flag(PL_STATUS_FLAG_PLUG_CAL, PL_STATUS_FLAG_STOP, &obs->flag);
	return 0;
}

static void deinit_plugin(struct plug_interface *pl)
{

}


static struct plugin_cal mxt_plugin_cal;
static struct plugin_ac mxt_plugin_ac;
static struct plugin_proci mxt_plugin_pi;
static struct plugin_misc mxt_plugin_msc;
static struct plugin_clip mxt_plugin_clp;
static struct plugin_wdg mxt_plugin_wd;

static int mxt_plugin_pre_init(struct mxt_data *data)
{
	struct plug_interface *pl = &data->plug;
	struct device *dev = &data->client->dev;
	struct plug_observer *obs = &pl->observer;
	int error;

	dev_info(dev, "%s: plugin version 0x%x\n",
			__func__,PLUG_VERSION);

	if (!data->object_table)
		return -ENODEV;

	if (pl->inited) {
		dev_err(dev, "%s: plugin has been initilized\n",
				__func__);
		return -EEXIST;
	}

	pl->dev = data;
	error = mxt_get_init_cfg(data);
	if (error) {
		dev_err(dev, "pre init plugin get default config failed\n");
		return error;
	}

	clear_flag(PL_STATUS_FLAG_REG_INIT,&obs->flag);

	return 0;
}

static int mxt_plugin_init(struct mxt_data *data)
{
	struct plug_interface *pl = &data->plug;
	struct device *dev = &data->client->dev;
	struct plug_observer *obs = &pl->observer;
	int error;

	dev_info(dev, "%s: plugin version 0x%x\n",
			__func__,PLUG_VERSION);

	if (!data->object_table)
		return -ENODEV;

	if (pl->inited) {
		dev_err(dev, "%s: plugin has been initilized\n",
				__func__);
		return -EEXIST;
	}

	pl->dev = data;
	pl->cal = &mxt_plugin_cal;
	pl->ac = &mxt_plugin_ac;
	pl->pi = &mxt_plugin_pi;
	pl->msc = &mxt_plugin_msc;
	pl->clp = &mxt_plugin_clp;
	pl->wd = &mxt_plugin_wd;
#if defined(CONFIG_MXT_IRQ_WORKQUEUE)
	pl->active_thread = mxt_active_proc_thread;
#endif

	error = mxt_get_init_cfg(data);
	if (error) {
		dev_err(dev, "init plugin get default config failed\n");
		return error;
	}

	error = init_plugin(pl);
	if (error) {
		dev_err(dev, "init plugin failed\n");
		deinit_plugin(pl);
		return error;
	} 

	if (pl->cal->init) {
		pl->cal->dev = (void *)pl;
		pl->cal->dcfg = &pl->init_cfg;
		pl->cal->set_and_clr_flag = plug_set_and_clr_flag;
		pl->cal->set_t6 = mxt_set_t6;
		pl->cal->set_t6_cal= mxt_set_t6_cal;
		pl->cal->emu_plugin_hook_t6 = emu_mxt_plugin_hook_t6;
		pl->cal->set_diagnostic_command_fast = mxt_diagnostic_command_fast_write;
		pl->cal->get_diagnostic_data_fast = mxt_diagnostic_command_fast_read;
		if (pl->cal->init(pl->cal) != 0) {
			dev_err(dev, "init cal plugin failed, disable this plugin\n");
			pl->cal->deinit(pl->cal);
			memset(pl->cal, 0, sizeof(struct plugin_cal));
		}
	} else {
		dev_info(dev, "doesn't get any cal plugin\n");
		memset(pl->cal, 0, sizeof(struct plugin_cal));
	}

	if (pl->ac->init) {
		pl->ac->dev = (void *)pl;
		pl->ac->dcfg = &pl->init_cfg;
		pl->ac->set_and_clr_flag = plug_set_and_clr_flag;
		pl->ac->set_t6_cal= mxt_set_t6_cal;
		if (pl->ac->init(pl->ac) != 0) {
			dev_err(dev, "init ac plugin failed, disable this plugin\n");
			pl->ac->deinit(pl->ac);
			memset(pl->ac, 0, sizeof(struct plugin_ac));
		}
	} else {
		dev_info(dev, "doesn't get any ac plugin\n");
		memset(pl->ac, 0, sizeof(struct plugin_ac));
	}

	if (pl->pi->init) {
		pl->pi->dev = (void *)pl;
		pl->pi->dcfg = &pl->init_cfg;
		pl->pi->set_and_clr_flag = plug_set_and_clr_flag;
		pl->pi->set_obj_cfg = mxt_set_obj_cfg;
		pl->pi->get_obj_cfg = mxt_get_obj_cfg;
		pl->pi->get_diagnostic_data = mxt_get_diagnostic_data;
		pl->pi->reset = mxt_set_reset;
		pl->pi->emu_plugin_hook_t6 = emu_mxt_plugin_hook_t6;
		pl->pi->active_thread = mxt_plugin_active_thread;
		if (pl->pi->init(pl->pi) != 0) {
			dev_err(dev, "init pi plugin failed, disable this plugin\n");
			pl->pi->deinit(pl->pi);
			memset(pl->pi, 0, sizeof(struct plugin_proci));
		}
	}else{
		dev_info(dev, "doesn't get any pi plugin\n");
		memset(pl->pi, 0, sizeof(struct plugin_proci));
	}

	if (pl->msc->init) {
		pl->msc->dev = (void *)pl;
		pl->msc->dcfg = &pl->init_cfg;
		pl->msc->set_and_clr_flag = plug_set_and_clr_flag;
		pl->msc->set_t6_cal= mxt_set_t6_cal;
		pl->msc->set_obj_cfg = mxt_set_obj_cfg;
		pl->msc->get_obj_cfg = mxt_get_obj_cfg;
		pl->msc->get_diagnostic_data = mxt_get_diagnostic_data;
		pl->msc->active_thread = mxt_plugin_active_thread;
		if (pl->msc->init(pl->msc, obs->flag) != 0) {
			dev_err(dev, "init msc plugin failed, disable this plugin\n");
			pl->msc->deinit(pl->msc);
			memset(pl->msc, 0, sizeof(struct plugin_misc));
		}
	}else{
		dev_info(dev, "doesn't get any msc plugin\n");
		memset(pl->msc, 0, sizeof(struct plugin_misc));
	}

	if (pl->clp->init) {
		pl->clp->dev = (void *)pl;
		pl->clp->dcfg = &pl->init_cfg;
		pl->clp->set_and_clr_flag = plug_set_and_clr_flag;
		pl->clp->set_t6_cal= mxt_set_t6_cal;
		pl->clp->set_obj_cfg = mxt_set_obj_cfg;
		pl->clp->get_obj_cfg = mxt_get_obj_cfg;
		pl->clp->get_diagnostic_data = mxt_get_diagnostic_data;
		pl->clp->active_thread = mxt_plugin_active_thread;
		if (pl->clp->init(pl->clp) != 0) {
			dev_err(dev, "init clp plugin failed, disable this plugin\n");
			pl->clp->deinit(pl->clp);
			memset(pl->clp, 0, sizeof(struct plugin_clip));
		}
	}else{
		dev_info(dev, "doesn't get any clp plugin\n");
		memset(pl->clp, 0, sizeof(struct plugin_clip));
	}

	if (pl->wd->init) {
		pl->wd->dev = (void *)pl;
		pl->wd->dcfg = &pl->init_cfg;
		pl->wd->set_and_clr_flag = plug_set_and_clr_flag;
		pl->wd->reset = mxt_set_reset;
		pl->wd->set_obj_cfg = mxt_set_obj_cfg;
		pl->wd->get_obj_cfg = mxt_get_obj_cfg;
		pl->wd->active_thread = mxt_plugin_active_thread;
		if (pl->wd->init(pl->wd) != 0) {
			dev_err(dev, "init wd plugin failed, disable this plugin\n");
			pl->wd->deinit(pl->wd);
			memset(pl->wd, 0, sizeof(struct plugin_wdg));
		}
	}else{
		dev_info(dev, "doesn't get any wd plugin\n");
		memset(pl->wd, 0, sizeof(struct plugin_wdg));
	}

	if (pl->cal->init || pl->ac->init || pl->pi->init|| pl->msc->init|| pl->clp->init || pl->wd->init) {
		pl->inited = true;
		if (pl->cal->init) {
			mxt_plugin_hook_t6(pl,MXT_T6_STATUS_RESET|MXT_T6_STATUS_CAL);//init as reset status
			mxt_plugin_hook_t6(pl,0);
		}
	}
	return 0;
}

static void mxt_plugin_deinit(struct plug_interface *pl)
{
	struct plug_observer *obs = &pl->observer;

	printk(KERN_ERR "mxt_plugin_deinit\n");
	if (!pl->inited)
		return;
	
	if (!test_flag(PL_STATUS_FLAG_STOP, &obs->flag)) {
		printk(KERN_ERR "mxt_plugin_deinit not stop\n");
		set_and_clr_flag(PL_STATUS_FLAG_FORCE_STOP, PL_STATUS_FLAG_STOP, &obs->flag);
	}

	pl->inited = false;

	if (pl->cal->deinit) {
		pl->cal->deinit(pl->cal);
		memset(pl->cal, 0, sizeof(struct plugin_cal));
	}
	
	if (pl->ac->deinit) {
		pl->ac->deinit(pl->ac);
		memset(pl->ac, 0, sizeof(struct plugin_ac));
	}
	
	if (pl->pi->deinit) {
		pl->pi->deinit(pl->pi);
		memset(pl->pi, 0, sizeof(struct plugin_proci));
	}

	if (pl->msc->deinit) {
		pl->msc->deinit(pl->msc);
		memset(pl->msc, 0, sizeof(struct plugin_misc));
	}

	deinit_plugin(pl);
}

static ssize_t mxt_plugin_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;
	struct plug_observer *obs = &pl->observer;
	int i;

	dev_info(dev, "[mxt]PLUG_VERSION: 0x%x\n",PLUG_VERSION);

	if (!pl->inited)
		return -ENODEV;
	
	dev_info(dev, "[mxt]Plug cfg :\n");

	dev_info(dev, "[mxt]dcfg: t9_t100 start(%u,%u) size(%u,%u)\n",
			pl->init_cfg.t9_t100.x0,
			pl->init_cfg.t9_t100.y0,
			pl->init_cfg.t9_t100.xsize,
			pl->init_cfg.t9_t100.ysize);

	dev_info(dev, "[mxt]dcfg: t15 start(%u,%u) size(%u,%u)\n",
			pl->init_cfg.t15.x0,
			pl->init_cfg.t15.y0,
			pl->init_cfg.t15.xsize,
			pl->init_cfg.t15.ysize);

	for (i = 0; i < MX_SUM; i++) {
		struct rect *m = &pl->init_cfg.m[i];
		dev_info(dev, "[mxt]dcfg: Matrix %d (%d,%d)~(%d,%d)\n",
				i,
				m->x0,
				m->y0,
				m->x1,
				m->y1);
	}
	dev_info(dev, "[mxt]\n");

	dev_info(dev, "[mxt]Plug obs :\n");
	dev_info(dev, "[mxt]status: Flag=0x%08lx\n",
			obs->flag);
	dev_info(dev, "[mxt]\n");

	if (pl->cal->show)
		pl->cal->show(pl->cal);

	if (pl->ac->show)
		pl->ac->show(pl->ac);

	if (pl->pi->show)
		 pl->pi->show(pl->pi);

	if (pl->msc->show)
		 pl->msc->show(pl->msc);

	if (pl->clp->show)
		 pl->clp->show(pl->clp);

	if (pl->wd->show)
		 pl->wd->show(pl->wd);

	return 0;
}

static ssize_t mxt_plugin_store(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t count)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;
	struct plug_observer *obs = &pl->observer;
	int config[16];
	int object,offset,ofs,ret;
	char name[255];

	if (!pl->inited)
		return -ENODEV;

	dev_info(dev, "[mxt]%s\n",buf);

	if (count > 4 && count < sizeof(name)) {
		ret = sscanf(buf, "%s %n", name, &offset);
		dev_info(dev, "name %s, offset %d, ret %d\n",name,offset,ret);
		if (ret == 1) {
			if (strncmp(name, "pl", 2) == 0) {
				dev_info(dev, "cmd 'pl': %s\n",buf + offset);
				ret = sscanf(buf + offset, "t%d%n", &object, &ofs);
				dev_info(dev, "object %d, ofs %d, ret %d\n",object,ofs,ret);
				if (count > 5 &&  ret == 1) {
					offset += ofs;
					dev_info(dev, "parse %s\n",buf + offset);
					switch (object) {
						case 8:
						case 100:
							dev_err(dev, "[mxt]Not support command\n");
							break;
						default:
							dev_err(dev, "[mxt]Invalid object %d, %s\n",object, buf + offset);
							return -EINVAL;
					}
				} else if (sscanf(buf + offset, "status: Flag=0x%lx\n",
							&obs->flag) > 0) {
					dev_info(dev, "[mxt] OK\n");
				}else if (sscanf(buf + offset, "enable %x\n",
					&config[0]) == 1) {
					config[0] = ((config[0]) << PL_STATUS_FLAG_HIGH_MASK_SHIFT) & PL_STATUS_FLAG_PAUSE_MASK;
					set_and_clr_flag(config[0],PL_STATUS_FLAG_PAUSE_MASK,&obs->flag);
					dev_info(dev, "[mxt]OK(Flag = 0x%08lx)\n",obs->flag);
				} else {
					dev_err(dev, "Unknow parse pl command: %s  object %d, ofs %d, ret %d\n",buf,object,ofs,ret);
				}
			} else if (strncmp(name, "cal", 3) == 0) {
				dev_info(dev, "cmd = 'cal': %s",buf + 4);
				if (pl->cal->store)
					pl->cal->store(pl->cal, buf + 4, count - 4);
			} else if (strncmp(name, "ac", 2) == 0) {
				dev_info(dev, "cmd = 'ac': %s",buf + 3);
				if (pl->ac->store)
					pl->ac->store(pl->ac, buf + 3, count - 3);
			}else if (strncmp(name, "pi", 2) == 0) {
				dev_info(dev, "cmd = 'pi': %s",buf + 3);
				if (pl->pi->store)
					pl->pi->store(pl->pi, buf + 3, count - 3);
			}else if (strncmp(name, "msc", 3) == 0) {
				dev_info(dev, "cmd = 'msc': %s",buf + 3);
				if (pl->msc->store)
					pl->msc->store(pl->msc, buf + 4, count - 4);					
			} else if (strncmp(name, "clp", 3) == 0) {
				dev_info(dev, "cmd =  clp': %s",buf + 3);
				if (pl->clp->store)
					pl->clp->store(pl->clp, buf + 4, count - 4);					
			}else if (strncmp(name, "wd", 2) == 0) {
				dev_info(dev, "cmd =  wd': %s",buf + 2);
				if (pl->wd->store)
					pl->wd->store(pl->wd, buf + 3, count - 3);					
			}else {
				dev_err(dev, "Unknow command: %s\n",buf);
				return -EINVAL;
			}
		} else{
			dev_err(dev, "Unknow parameter, ret %d\n",ret);
		}

		if (pl->active_thread)
			pl->active_thread(pl->dev,MXT_EVENT_EXTERN);
		return count;
	} else {
		dev_dbg(dev, "Unknow count\n");
		return -EINVAL;
	}
}

static ssize_t mxt_plugin_tag_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;
#if defined(CONFIG_MXT_MISC_WORKAROUND)
	u8 id[MISC_PDS_PID_LEN];
#endif
	int count = 0;

	if (!pl->inited)
		return -ENODEV;

	dev_info(dev, "[mxt]Plug tag :\n");

	if (data->info) {
		count = scnprintf(buf + count, PAGE_SIZE - count, "CFG: %u.%u.%u\n",
				pl->init_cfg.t38.data[0],
				pl->init_cfg.t38.data[1],
				pl->init_cfg.t38.data[2]);

		count += snprintf(buf + count, PAGE_SIZE - count, "FW: %02X_%02X_%u.%u_%02X\n",
				data->info->family_id,
				data->info->variant_id,
				(data->info->version & 0xF0) >> 4,
				(data->info->version & 0x0F),
				data->info->build);
	}

#if defined(CONFIG_MXT_MISC_WORKAROUND)
	if (pl->msc) {
		if (pl->msc->get_pid_val) {
			pl->msc->get_pid_val(pl->msc, id, sizeof(id));

			count += scnprintf(buf + count, PAGE_SIZE - count, "UID: %u.%u.%u.%u.%u.%u.%u.%u\n",
						id[0],
						id[1],
						id[2],
						id[3],
						id[4],
						id[5],
						id[6],
						id[7]	);
		}
	}
#endif

	dev_info(dev, "[mxt] %s\n", buf);

	return count;
}

#if defined(CONFIG_MXT_CAL_WORKAROUND)
static ssize_t mxt_plugin_cal_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;

	if (!pl->inited)
		return -ENODEV;

	return plugin_cal_show(pl->cal, buf, PAGE_SIZE);
}

static ssize_t mxt_plugin_cal_store(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t count)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;
	int ret;

	if (!pl->inited)
		return -ENODEV;

	ret = plugin_cal_store(pl->cal, buf, count);
	if (pl->active_thread)
		pl->active_thread(pl->dev,MXT_EVENT_EXTERN);
	return ret;
}
#endif

#if defined(CONFIG_MXT_PI_WORKAROUND)
ssize_t plugin_functon_op(struct plug_interface *pl,char *buf, size_t count, unsigned long op, bool show)
{ 
	struct plug_observer *obs = &pl->observer;
	int i;
	char c;

	if (!pl->inited)
		return 0;

	op &= PL_FUNCTION_FLAG_MASK;

	if (show) {   
		c = test_flag(op, &obs->flag) ? '1' : '0';
		return scnprintf(buf, PAGE_SIZE, "%c\n", c);
	}else{
		if (sscanf(buf, "%u", &i) == 1 && i < 2) {
			if (i == 1) {
				set_flag(op, &obs->flag);
			}else{
				clear_flag(op, &obs->flag);
				if (op == PL_FUNCTION_FLAG_GLOVE) {
					//mxt_soft_reset((struct mxt_data *)pl->dev);
					mxt_t6_command((struct mxt_data *)pl->dev, MXT_COMMAND_CALIBRATE, 1, false);
				}
			}
			return count;
		} else {
			return -EINVAL;
		}
	}
}

static ssize_t mxt_plugin_glove_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;

	if (!pl->inited)
		return -ENODEV;

	return plugin_functon_op(pl, buf, 0, PL_FUNCTION_FLAG_GLOVE, true);
}

static ssize_t mxt_plugin_glove_store(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t count)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;
	
	int ret;

	if (!pl->inited)
		return -ENODEV;

	ret = plugin_functon_op(pl, (char *)buf, count, PL_FUNCTION_FLAG_GLOVE, false);
	if (pl->active_thread)
		pl->active_thread(pl->dev,MXT_EVENT_EXTERN);

	return ret;
}

static ssize_t mxt_plugin_stylus_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;

	if (!pl->inited)
		return -ENODEV;

	return plugin_functon_op(pl, buf, 0, PL_FUNCTION_FLAG_STYLUS, true);
}

static ssize_t mxt_plugin_stylus_store(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t count)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;
	int ret;

	if (!pl->inited)
		return -ENODEV;

	ret = plugin_functon_op(pl, (char *)buf, count, PL_FUNCTION_FLAG_STYLUS, false);
	if (pl->active_thread)
		pl->active_thread(pl->dev,MXT_EVENT_EXTERN);
	printk(KERN_INFO "mxt ret %d\n", ret);
	return ret;
}

static ssize_t mxt_plugin_gesture_list_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;

	if (!pl->inited)
		return -ENODEV;

	return plugin_proci_pi_gesture_show(pl->pi, buf, PAGE_SIZE);
}

static ssize_t mxt_plugin_gesture_list_store(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t count)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;
	int ret;

	if (!pl->inited)
		return -ENODEV;

	ret = plugin_proci_pi_gesture_store(pl->pi, buf, count);
	if (pl->active_thread)
		pl->active_thread(pl->dev,MXT_EVENT_EXTERN);
	return ret;
}

static ssize_t mxt_plugin_gesture_trace_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;

	if (!pl->inited)
		return -ENODEV;

	return plugin_proci_pi_trace_show(pl->pi, buf, PAGE_SIZE);
}
#endif

#if defined(CONFIG_MXT_MISC_WORKAROUND)
static ssize_t mxt_plugin_misc_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;

	if (!pl->inited)
		return -ENODEV;

	return plugin_misc_show(pl->msc, buf, PAGE_SIZE);
}

static ssize_t mxt_plugin_misc_store(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t count)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;
	int ret;

	if (!pl->inited)
		return -ENODEV;

	ret = plugin_misc_store(pl->msc, buf, count);
	if (pl->active_thread)
		pl->active_thread(pl->dev,MXT_EVENT_EXTERN);
	return ret;
}
#endif
#if defined(CONFIG_MXT_CLIP_WORKAROUND)
static ssize_t mxt_plugin_clip_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;

	if (!pl->inited)
		return -ENODEV;

	return plugin_clip_show(pl->clp, buf, PAGE_SIZE);
}

static ssize_t mxt_plugin_clip_store(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t count)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;
	int ret;

	if (!pl->inited)
		return -ENODEV;

	ret = plugin_clip_store(pl->clp, buf, count);
	if (pl->active_thread)
		pl->active_thread(pl->dev,MXT_EVENT_EXTERN);
	return ret;
}

static ssize_t mxt_plugin_clip_tag_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct mxt_data *data = dev_get_drvdata(dev);
	struct plug_interface *pl = &data->plug;

	if (!pl->inited)
		return -ENODEV;

	return plugin_clip_tag_show(pl->clp, buf, PAGE_SIZE);
}

#endif


